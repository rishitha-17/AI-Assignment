"""
Research Agent using Pydantic-AI with Tool Calls and Logfire Instrumentation
Generated by Copilot
"""

import os
from datetime import datetime
from typing import Optional, List, Dict
import logfire
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext


# Configure Logfire with instrumentation (no console output)
# To use a different project, set the project_name parameter
logfire.configure(console=False)

with logfire.span('Initializing Research Agent'):
    logfire.info('Research Agent initialization started')
    
    # Gemini API configuration
    GEMINI_API_KEY = "AIzaSyAJ0-aZ1knp4YejSe5RUvX6mEKMb_9r22A"
    os.environ['GEMINI_API_KEY'] = GEMINI_API_KEY
    logfire.info('Gemini API key configured')


# Define dependencies for the agent with message history
class ResearchDependencies(BaseModel):
    """Dependencies for the research agent with conversation history"""
    session_id: str = Field(default_factory=lambda: datetime.now().strftime("%Y%m%d_%H%M%S"))
    max_tokens: int = 2000
    message_history: List[Dict[str, str]] = Field(default_factory=list)
    
    def add_message(self, role: str, content: str):
        """Add a message to the conversation history"""
        self.message_history.append({
            'role': role,
            'content': content,
            'timestamp': datetime.now().isoformat()
        })
        logfire.info(f'Message added to history: {role}', content_preview=content[:100])
    
    def get_history_summary(self) -> str:
        """Get a summary of the conversation history"""
        return f"Total messages: {len(self.message_history)}"


# Create the research agent with Gemini
with logfire.span('Creating Agent'):
    agent = Agent(
        'google-gla:gemini-2.5-flash'
,
        deps_type=ResearchDependencies,
        system_prompt=(
            'You are a helpful research assistant. You can perform calculations, '
            'search for information, and retrieve data. Use the available tools '
            'to answer questions thoroughly and accurately.'
        ),
    )
    logfire.info('Agent created successfully')


@agent.tool
async def calculate(ctx: RunContext[ResearchDependencies], expression: str) -> str:
    """
    Perform mathematical calculations.
    
    Args:
        ctx: The run context
        expression: A mathematical expression to evaluate (e.g., "2 + 2", "sqrt(16)")
    
    Returns:
        The result of the calculation
    """
    with logfire.span('calculate_tool', expression=expression):
        logfire.info(f'Calculating expression: {expression}')
        
        try:
            # Safe evaluation of mathematical expressions
            import math
            
            # Create a safe namespace with math functions
            safe_dict = {
                'sqrt': math.sqrt,
                'pow': math.pow,
                'abs': abs,
                'round': round,
                'sin': math.sin,
                'cos': math.cos,
                'tan': math.tan,
                'log': math.log,
                'exp': math.exp,
                'pi': math.pi,
                'e': math.e,
            }
            
            result = eval(expression, {"__builtins__": {}}, safe_dict)
            logfire.info(f'Calculation successful', result=result)
            return f"The result is: {result}"
        
        except Exception as e:
            error_msg = f"Error calculating: {str(e)}"
            logfire.error(error_msg, exc_info=e)
            return error_msg


@agent.tool
async def search_database(ctx: RunContext[ResearchDependencies], query: str, category: str = "general") -> str:
    """
    Search a simulated knowledge database for information.
    
    Args:
        ctx: The run context
        query: The search query
        category: The category to search in (general, science, history, technology)
    
    Returns:
        Search results from the database
    """
    with logfire.span('search_database_tool', query=query, category=category):
        logfire.info(f'Searching database: query="{query}", category="{category}"')
        
        # Simulated database with sample information
        database = {
            "science": {
                "photosynthesis": "Photosynthesis is the process by which plants convert light energy into chemical energy, producing glucose and oxygen from carbon dioxide and water.",
                "dna": "DNA (Deoxyribonucleic Acid) is a molecule that carries genetic instructions for life. It consists of two strands forming a double helix structure.",
                "gravity": "Gravity is a fundamental force of nature that attracts objects with mass toward each other. It was first described by Isaac Newton.",
                "atom": "An atom is the basic unit of matter consisting of a nucleus (protons and neutrons) surrounded by electrons.",
            },
            "history": {
                "world war 2": "World War II (1939-1945) was a global conflict involving most of the world's nations, divided into the Allies and Axis powers.",
                "renaissance": "The Renaissance was a period of cultural rebirth in Europe from the 14th to 17th century, marked by advances in art, science, and philosophy.",
                "industrial revolution": "The Industrial Revolution (1760-1840) was a period of major industrialization that transformed economies from agrarian to industrial.",
            },
            "technology": {
                "artificial intelligence": "AI is the simulation of human intelligence by machines, enabling them to learn, reason, and solve problems.",
                "blockchain": "Blockchain is a distributed ledger technology that records transactions across multiple computers securely and transparently.",
                "quantum computing": "Quantum computing uses quantum mechanics principles to process information, potentially solving complex problems faster than classical computers.",
                "machine learning": "Machine learning is a subset of AI that enables systems to learn and improve from experience without being explicitly programmed.",
            },
            "general": {
                "python": "Python is a high-level programming language known for its simplicity and versatility, widely used in web development, data science, and AI.",
                "climate change": "Climate change refers to long-term shifts in global temperatures and weather patterns, primarily caused by human activities.",
            }
        }
        
        # Search logic
        query_lower = query.lower()
        results = []
        
        # Search in specified category
        if category in database:
            for key, value in database[category].items():
                if query_lower in key or key in query_lower:
                    results.append(f"{key.title()}: {value}")
        
        # If no results in category, search all categories
        if not results:
            for cat, entries in database.items():
                for key, value in entries.items():
                    if query_lower in key or key in query_lower:
                        results.append(f"{key.title()} ({cat}): {value}")
        
        if results:
            result_text = "\n\n".join(results)
            logfire.info(f'Search successful', results_count=len(results))
            return result_text
        else:
            logfire.warning(f'No results found for query: {query}')
            return f"No information found for '{query}' in the database. Try a different search term or category."


@agent.tool
async def get_current_info(ctx: RunContext[ResearchDependencies], info_type: str) -> str:
    """
    Get current system information.
    
    Args:
        ctx: The run context
        info_type: Type of information to retrieve (date, time, session)
    
    Returns:
        The requested information
    """
    with logfire.span('get_current_info_tool', info_type=info_type):
        logfire.info(f'Getting current info: {info_type}')
        
        now = datetime.now()
        
        info_map = {
            "date": now.strftime("%Y-%m-%d"),
            "time": now.strftime("%H:%M:%S"),
            "datetime": now.strftime("%Y-%m-%d %H:%M:%S"),
            "session": ctx.deps.session_id,
            "history": ctx.deps.get_history_summary(),
        }
        
        result = info_map.get(info_type.lower(), f"Unknown info type: {info_type}")
        logfire.info(f'Info retrieved successfully', result=result)
        return result


@agent.tool
async def analyze_data(ctx: RunContext[ResearchDependencies], data: str, analysis_type: str = "summary") -> str:
    """
    Analyze text data and provide insights.
    
    Args:
        ctx: The run context
        data: The data to analyze
        analysis_type: Type of analysis (summary, word_count, sentiment)
    
    Returns:
        Analysis results
    """
    with logfire.span('analyze_data_tool', analysis_type=analysis_type, data_length=len(data)):
        logfire.info(f'Analyzing data: type="{analysis_type}", length={len(data)}')
        
        if analysis_type == "word_count":
            words = data.split()
            result = f"Word count: {len(words)} words, {len(data)} characters"
        
        elif analysis_type == "sentiment":
            # Simple sentiment analysis based on keywords
            positive_words = ["good", "great", "excellent", "happy", "wonderful", "amazing", "positive", "love", "best"]
            negative_words = ["bad", "poor", "terrible", "sad", "awful", "negative", "worst", "hate", "horrible"]
            
            data_lower = data.lower()
            pos_count = sum(1 for word in positive_words if word in data_lower)
            neg_count = sum(1 for word in negative_words if word in data_lower)
            
            if pos_count > neg_count:
                sentiment = "Positive"
            elif neg_count > pos_count:
                sentiment = "Negative"
            else:
                sentiment = "Neutral"
            
            result = f"Sentiment: {sentiment} (Positive keywords: {pos_count}, Negative keywords: {neg_count})"
        
        else:  # summary
            sentences = data.split('.')
            result = f"Summary: Text contains {len(sentences)} sentences. First sentence: {sentences[0].strip()}..."
        
        logfire.info(f'Analysis complete', analysis_type=analysis_type)
        return result


@agent.tool
async def search_wikipedia(ctx: RunContext[ResearchDependencies], query: str) -> str:
    """
    Search Wikipedia for real-world information about people, movies, history, etc.
    
    Args:
        ctx: The run context
        query: The search query for Wikipedia (e.g., person name, movie name, topic)
    
    Returns:
        Summary from Wikipedia or error message
    """
    with logfire.span('search_wikipedia_tool', query=query):
        logfire.info(f'Searching Wikipedia: query="{query}"')
        
        try:
            import wikipedia
            wikipedia.set_lang("en")
            
            # Search Wikipedia
            search_results = wikipedia.search(query, results=5)
            
            if not search_results:
                logfire.warning(f'No Wikipedia results found for: {query}')
                return f"No Wikipedia articles found for '{query}'. Try rephrasing the search."
            
            # Try each search result until we find one that works
            for search_term in search_results:
                try:
                    page = wikipedia.page(search_term, auto_suggest=False)
                    summary = wikipedia.summary(search_term, sentences=4, auto_suggest=False)
                    
                    result = f"{summary}"
                    logfire.info(f'Wikipedia search successful', article_title=page.title)
                    return result
                    
                except wikipedia.DisambiguationError as e:
                    # If disambiguation, try the first option
                    try:
                        page = wikipedia.page(e.options[0], auto_suggest=False)
                        summary = wikipedia.summary(e.options[0], sentences=4, auto_suggest=False)
                        result = f"{summary}"
                        logfire.info(f'Wikipedia search successful (disambiguation)', article_title=page.title)
                        return result
                    except:
                        continue
                
                except wikipedia.PageError:
                    continue
            
            return f"Could not find detailed Wikipedia information for '{query}'. Search results found: {', '.join(search_results[:3])}"
        
        except Exception as e:
            error_msg = f"Error searching Wikipedia: {str(e)}"
            logfire.error('Wikipedia search error', error=str(e))
            return error_msg
            return error_msg


async def run_research_query(query: str, deps: Optional[ResearchDependencies] = None) -> tuple[str, ResearchDependencies]:
    """
    Run a research query using the agent.
    
    Args:
        query: The research question or task
        deps: Optional dependencies (will create new if None)
    
    Returns:
        Tuple of (response, updated_dependencies)
    """
    if deps is None:
        deps = ResearchDependencies()
    
    with logfire.span('run_research_query', query=query, session_id=deps.session_id):
        logfire.info(f'Running research query: {query}')
        
        # Add user query to history
        deps.add_message('user', query)
        
        try:
            # Build conversation history for context
            messages = []
            for msg in deps.message_history[:-1]:  # Exclude the current query we just added
                if msg['role'] in ['user', 'assistant']:
                    messages.append(f"{msg['role'].capitalize()}: {msg['content']}")
            
            # Add context to the query if there's history
            if messages:
                context = "\n".join(messages[-10:])  # Last 10 messages for context
                full_query = f"Previous conversation:\n{context}\n\nCurrent question: {query}"
            else:
                full_query = query
            
            result = await agent.run(full_query, deps=deps)
            response = result.output if hasattr(result, 'output') else str(result)
            
            # Add assistant response to history
            deps.add_message('assistant', response)
            
            logfire.info('Query completed successfully', response_length=len(response))
            return response, deps
        
        except Exception as e:
            error_msg = f"Error running query: {str(e)}"
            logfire.error('Error running query', error=str(e))
            deps.add_message('error', error_msg)
            return error_msg, deps


if __name__ == "__main__":
    import asyncio
    
    # Example usage
    async def main():
        print("=" * 80)
        print("Research Agent with Pydantic-AI, Gemini, and Logfire")
        print("=" * 80)
        print()
        
        # Create dependencies
        deps = ResearchDependencies()
        print(f"Session ID: {deps.session_id}\n")
        
        # Example queries
        queries = [
            "What is 25 * 4 + sqrt(144)?",
            "Search for information about artificial intelligence",
            "What is photosynthesis? Please search the science category.",
            "Analyze this text for sentiment: 'This is a wonderful and amazing product, I love it!'",
            "What is the current date and time?",
        ]
        
        for i, query in enumerate(queries, 1):
            print(f"\n{'=' * 80}")
            print(f"Query {i}: {query}")
            print(f"{'=' * 80}")
            
            response, deps = await run_research_query(query, deps)
            print(f"\nResponse: {response}\n")
        
        # Print conversation history
        print(f"\n{'=' * 80}")
        print("Conversation History")
        print(f"{'=' * 80}")
        print(f"Total messages: {len(deps.message_history)}")
        for msg in deps.message_history:
            print(f"\n[{msg['timestamp']}] {msg['role'].upper()}:")
            print(f"{msg['content'][:200]}...")
    
    asyncio.run(main())
